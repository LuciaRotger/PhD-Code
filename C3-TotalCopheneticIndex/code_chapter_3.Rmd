---
title: 'Chapter 3: The total cophenetic index'
author: "Lucia Rotger"
output:
  pdf_document:
    toc: true  
    extra_dependencies: ["color"]
  html_document:
    df_print: paged 
--- 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
```

<!-- ## Index -->
<!-- * [$\color{blue}{\text{Packages required}}$](#packs) -->
<!-- * [$\color{blue}{\text{List of all binary trees}}$](#bintrees) -->
<!-- * [$\color{blue}{\text{Common functions for Sections 3.5, 3.6 and 3.7}}$](#cofun) -->
<!-- * [$\color{blue}{\text{3.3 Expected value of $\Phi$ under the Yule model}}$](#eyphi) -->
<!-- * [$\color{blue}{\text{3.4 Expected value of $\Phi$ under the uniform model}}$](#euphi) -->
<!-- * [$\color{blue}{\text{3.5 On the variance of $\Phi$ under the uniform model}}$](#varphi) -->
<!-- * [$\color{blue}{\text{3.6 On the variance of $S$ under the uniform model}}$](#varsackin) -->
<!-- * [$\color{blue}{\text{3.7 On the covariance of $S$ and $\Phi$ under the uniform model}}$](#cov) -->
<!-- * [$\color{blue}{\text{3.8.1 The discriminative power of $\Phi$}}$](#ties) -->
<!-- * [$\color{blue}{\text{3.8.2 A test on TreeBASE}}$](#tb) -->
 

## Packages required {#packs}
The functions used in this chapter need these packages to be installed and loaded in the session
```{r, results='hide',warning=FALSE,message=FALSE}
library(Zseq)
library(gmp)
library(ape)
library(CollessLike)
```


## List of all binary trees {#bintrees}
We have obtained all the phylogenetic trees in $\mathcal{BT}_n$ for $n=3,\ldots,8$ with the package *phylonetwork* for *Python*:

```{python, python.reticulate=FALSE, eval=FALSE}
import phylonetwork.generators as gen
from phylonetwork.distances import cophenetic_distance as cophdist
from math import factorial

for n in range(3,9):
    taxa = [str(i+1) for i in range(n)]
    tg = gen.all_trees(taxa = taxa, binary = True, nested_taxa = False)
    trees = list(tg)
    newicks = []
    file = open("bintrees-n"+str(n)+".txt", "w+")
    for i in range(len(trees)):
        newicks.append(trees[i].eNewick())
        print >>file, newicks[i]
    file.close()
```

The resulting lists of trees can be consulted in the [$\color{blue}{\text{\emph{List of Trees}}}$](https://github.com/LuciaRotger/PhD-Code/tree/master/List%20of%20Trees) folder of the GitHub repository.

***

## General functions {#gefun}
Next functions are needed in some computations of the sections below.
```{r common} 
big.factorial = function(n){
  if(n<2) return(1)
  return(Factorial(n+1)[n+1])
}

big.double.factorial = function(n){
  if(n<2) return(1)
  m = (n+2+n%%2)/2
  return(Factorial.Double(m,odd=(n%%2==1))[m])
}

big.binomial = function(n,k){
  return(big.factorial(n)/(big.factorial(k)*big.factorial(n-k)))
}

Cknk = function(k,n){
  return(big.binomial(n,k)*((big.double.factorial(2*k-3)*
          big.double.factorial(2*(n-k)-3))/(2*big.double.factorial(2*n-3))))
}
```

***

## 3.3 Expected value of $\Phi$ under the Yule model {#eyphi}
The formula in Theorem 3.19 can be computed with the following function:
```{r}
harmonic=function(n){return(sum(1/(1:n)))}
EYPhi=function(n){
  return(n*(n+1-2*harmonic(n)))
}
```

For $n=3,...,20$ the results are:
```{r}
sapply(3:20,EYPhi)
```

To double-check the formula, we have computed the values of $E_Y(\Phi)$, for $n=3,\ldots,8$, from the cophenetic indices of all trees in the corresponding $\mathcal{BT}_n$. 
 
First of all, we have considered all the phylogenetic trees in $\mathcal{BT}_n$ for $n=3,\ldots,8$ obtained with the package *phylonetwork* for *Python* in [$\color{blue}{\text{this section}}$](#bintrees).  

Moreover, we have to take into consideration the probabilities of each tree under the Yule model: 
```{r,eval=FALSE}
yule.prob = function(tree){
  if (class(tree)=="phylo") 
    tree=graph.edgelist(tree$edge, directed=TRUE)  
  sp = shortest.paths(tree,mode = "out")
  deg = degree(tree,mode="out")
  leaves = which(deg==0)
  n = length(leaves) 
  k.node = function(node){
    subtree=which(sp[node,]<Inf)
    return(length(intersect(leaves,subtree)))
  } 
  kappas = sapply(which(deg>0), k.node) 
  value = (2^(n-1)/as.numeric(big.factorial(n)))*prod(1/(kappas-1))
  return(value)
} 
```

Afterwards, we can compute the total cophenetic index with the package *CollessLike* and the expected value of the indices of each $n$
```{r,eval=FALSE}
exp.yule = c()
for(n in 3:8){ 
  trees=read.tree(file=paste("./bintrees-n",n,".txt",sep=""))
  indices = sapply(trees, cophen.index)
  probs=sapply(trees, yule.prob)
  exp.vule[n]=sum(indices*probs)
} 
```
Obtaining the following results:

$n$          | 3 |    4   |   5    |   6  |   7  |    8 
-------------|:---:|:---:|:------:|:------:|:-------:|:-------:
$E_Y(\Phi_n)$| 1 | 3.3333 | 7.1667 | 12.6 | 19.7 | 28.5143

agreeing with the figures given by our formula.

***

## 3.4 Expected value of $\Phi$ under the uniform model {#euphi}
The formula in Theorem 3.25 can be computed with the following function (`big.double.factorial` from [$\color{blue}{\text{common functions}}$](#cofun) is needed): 
```{r}
EUPhi = function(n){
  return(as.numeric((n*(n-1)/4)*(big.double.factorial(2*n-2)/
                                   big.double.factorial(2*n-3)-2)))
}
```

For $n=3,...,20$ the results are:
```{r}
sapply(3:20,EUPhi)
```

To double-check the formula, we have computed the values of $E_U(\Phi)$, for $n=3,\ldots,8$, from the cophenetic indices of all trees in the corresponding $\mathcal{BT}_n$.
 
First of all, we have considered all the phylogenetic trees in $\mathcal{BT}_n$ for $n=3,\ldots,8$ obtained with the package *phylonetwork* for *Python* in [$\color{blue}{\text{this section}}$](#bintrees). 

Afterwards, we can compute the total cophenetic index with the package *CollessLike* and the expected value, under the uniform model, of the indices of each $n$
```{r,eval=FALSE}
exp.uni = c()
for(n in 3:8){ 
  trees=read.tree(file=paste("./bintrees-n",n,".txt",sep=""))
  indices = sapply(trees, cophen.index) 
  exp.uni[n]=mean(indices)
} 
```
Obtaining the following results:

$n$          | 3 |    4   |   5    |   6  |   7  |    8 
-------------|:---:|:---:|:------:|:------:|:-------:|:-------:
$E_U(\Phi_n)$| 1 | 3.6 | 8.2857 | 15.4762 | 25.5455 | 38.8345

agreeing with the figures given by our formula.

***

## 3.5 On the variance of $\Phi$ under the uniform model {#varphi}

### Computing the variance of $\Phi_n$ using our formula

We can compute $\sigma^2_U(\Phi_n)$ using the recurrence formula for
$E_U(\Phi_n^2)$ and the exact formula of $E_U(\Phi_2)^2$ and obtaining:
$$\sigma^2_U(\Phi_n)=E_U(\Phi_n^2)-E_U(\Phi_2)^2$$

The following functions are needed to compute the desired variance, in addition to the functions of the common block ([$\color{blue}{\text{see this section}}$](#cofun))
```{r,eval=FALSE}
EUPhi = function(n){
    return(as.numeric((n*(n-1)/4)*(big.double.factorial(2*n-2)/
                                     big.double.factorial(2*n-3)-2)))
}

term.Phi = function(n){
  return(mul.bigq(as.bigq(n*(n-1)/2),(mul.bigq(as.bigq((49*n^3-57*n^2-22*n+24)/48),
                  big.double.factorial(2*n-4)/big.double.factorial(2*n-3))-
                    as.bigq((63*n^2-95*n+28)/30)))) 
}

compute.EUPhi2 = function(n.max=500){
  terms = lapply(2:n.max,term.Phi)
  terms = c(0,terms)
  exp.values = list(0)
  for(n in 2:n.max){
    sums = 0
    if(n>2){ 
      for(k in 2:(n-1)){ 
        sums = sums + Cknk(k,n)*exp.values[[k]]
      }
      sums = 2*sums
    }
    sums = sums + terms[[n]]
    exp.values[[n]] = sums
    print(n)
  }
  exp.values = sapply(exp.values, as.numeric)
  write.table(exp.values,file = paste("EU(Phi2)",n.max,".txt",sep = ""),
              row.names = F,col.names = F)
  return(exp.values)
}

compute.varUPhi = function(exp.values,n.max=500){
  var.form = function(i)return(exp.values[i]-EUPhi(i)^2)
  var.values = sapply(1:n.max, var.form)
  write.table(var.values,file = paste("varU(Phi)",n.max,".txt",sep = ""),
              row.names = F,col.names = F)
  return(var.values)
}
```

We have computed these variances up to $n=1000$ with the following instructions:
```{r, eval=FALSE} 
exp.values.Phi = compute.EUPhi2(1000)
var.values.Phi = compute.varUPhi(exp.values.Phi,1000)
```
NOTE: these computations might take a long time to finish.

For $n=3,...,20$ the results have been:
```{r, echo=FALSE}
exp.values.Phi = read.table("./EU(Phi2)1000.txt")[,1]
var.values.Phi = read.table("./varU(Phi)1000.txt")[,1]
```
```{r}
exp.values.Phi[3:20]
var.values.Phi[3:20]
```

The rest of the values are available in the files "EU(Phi2)1000.txt" and "varU(Phi)1000.txt". 

We have estimated  the main order in the expansion of $\sigma_U^2(\Phi_n)$ as a function of $n$, by performing 
the minimum squares linear regression of $\ln(\sigma_U^2(\Phi_n))$ as a function of $\ln(n)$ for $n=900,\ldots, 1000$, 
```{r}
summary(lm(log(var.values.Phi[900:1000])~log(900:1000)))
```
and the result has been 
$$
\ln(\sigma_U^2(\Phi_n))\approx -3.8743868 + 5.0657352\cdot \ln(n),
$$
with a determination coefficient $R^2 \approx 1$. We conclude then that, according to our approximations, 
$\sigma_U^2(\Phi_n)$ is in $O(n^{5.0657})$. We conjecture that, actually, $\sigma_U^2(\Phi_n)$ is in $O(n^{5})$, the order of $E_U(\Phi_n)^2$.

Next figure displays $\ln(\sigma_U^2(\Phi_n))$ as a function of $\ln(n)$, together with the corresponding regression line. 
```{r}
plot(log(1:1000),log(var.values.Phi),xlab="log of the number of leaves",
     ylab="log of the variance")
reg.phi=lm(log(var.values.Phi[500:1000])~log(500:1000))
abline(reg.phi,col="blue",lwd=2)
```

### Computing the variance of $\Phi_n$ from the cophenetic indices {#realvarphi}

To double-check the recurrence, we have computed the values of
$\sigma_U(\Phi_n)$, for $n=3,\ldots,8$, from the cophenetic indices of all trees in the corresponding $\mathcal{BT}_n$.
 
First of all, we have considered all the phylogenetic trees in $\mathcal{BT}_n$ for $n=3,\ldots,8$ obtained with the package *phylonetwork* for *Python* in [$\color{blue}{\text{this section}}$](#bintrees).

Afterwards, we can compute the total cophenetic index with the package *CollessLike* and compute the variance of the indices of each $n$:
```{r,eval=FALSE}
var.n = function (vec) return(var(vec)*(length(vec)-1)/length(vec))
trees = list()
all.cophen.index = list()
real.var.Phi = c()
for(n in 3:8){
  trees[[n]] = read.tree(file = paste("bintrees-n",n,".txt",sep = ""))
  all.cophen.index[[n]] = sapply(trees[[n]],cophen.index)
  real.var.Phi[n] = var.n(all.cophen.index[[n]])
  print(paste("var(Phi",n,") = ",real.var.Phi[n],sep = ""))
}
```
Obtaining the following results:

$n$             | 3 |   4  |   5    |    6    |    7    |    8 
----------------|:---:|:---:|:------:|:------:|:-------:|:-------:
$\sigma^2_U(\Phi_n)$| 0 | 0.64 | 4.7755 | 19.5828 | 58.9752 | 146.2314

agreeing with the figures given by our recurrence.

***

## 3.6 On the variance of $S$ under the uniform model {#varsackin}

### Computing the variance of $S_n$ using our formula 

We can compute $\sigma^2_U(S_n)$ using the recurrence formula for
$E_U(S_n^2)$ and the exact formula of $E_U(S_n)^2$ and obtaining:
$$\sigma^2_U(S_n)=E_U(S_n^2)-E_U(S_n)^2$$

The following functions are needed to compute the desired variance, in addition to the functions of the common block ([$\color{blue}{\text{see this section}}$](#cofun))
```{r,eval=FALSE}
EUS = function(n){
    return(as.numeric(n*(big.double.factorial(2*n-2)/big.double.factorial(2*n-3)-1)))
}

term.S = function(n){
  return((5*n*2^(n-2)*big.factorial(n))/(big.double.factorial(2*n-3))-n*(5*n-2)) 
}

compute.EUS2 = function(n.max=500){
  terms = lapply(2:n.max,term.S)
  terms = c(0,terms)
  exp.values = list(0)
  for(n in 2:n.max){
    sums = 0
    if(n>2){ 
      for(k in 2:(n-1)){ 
        sums = sums + Cknk(k,n)*exp.values[[k]]
      }
      sums = 2*sums
    }
    sums = sums + terms[[n]]
    exp.values[[n]] = sums
    print(n)
  }
  exp.values = sapply(exp.values, as.numeric)
  write.table(exp.values,file = paste("EU(S2)",n.max,".txt",sep = ""),
              row.names = F,col.names = F)
  return(exp.values)
}

compute.varUS = function(exp.values, n.max){
  var.form = function(i)return(exp.values[i]-EUS(i)^2)
  var.values = sapply(1:n.max,var.form)
  write.table(var.values,file = paste("varU(S)",n.max,".txt",sep = ""),
              row.names = F,col.names = F)
  return(var.values)
}
```

We have computed these variances up to $n=1000$ with the following instructions:
```{r, eval=FALSE}
exp.values.S = compute.EUS2(1000)
var.values.S = compute.varUS(exp.values.S,1000)
```
NOTE: these computations might take a long time to finish.

For $n=3,...,20$ the results have been:
```{r, echo=FALSE}
exp.values.S = read.table("./EU(S2)1000.txt")[,1]
var.values.S = read.table("./varU(S)1000.txt")[,1]
```
```{r}
exp.values.S[3:20]
var.values.S[3:20]
```

The rest of the values are available in the files "EU(S2)1000.txt" and "varU(S)1000.txt". 

We have estimated  the main order in the expansion of $\sigma_U^2(S_n)$ as a function of $n$, by performing 
the minimum squares linear regression of $\ln(\sigma_U^2(S_n))$ as a function of $\ln(n)$ for $n=900,\ldots, 1000$, 
```{r}
summary(lm(log(var.values.S[900:1000])~log(900:1000)))
```
and the result has been 
$$
\ln(\sigma_U^2(S_n))\approx -2.347121 + 3.078995\cdot \ln(n),
$$
with a determination coefficient $R^2 \approx 1$. We conclude then that, according to our approximations, 
$\sigma_U^2(S_n)$ is in $O(n^{3.078995})$. We conjecture that, actually, $\sigma_U^2(S_n)$ is in $O(n^{3})$, the order of $E_U(S)^2$.

Next figure displays $\ln(\sigma_U^2(S_n))$ as a function of $\ln(n)$, together with the corresponding regression line and the approximation for $\sigma_U^2(S_n)$. 
```{r}
plot(log(1:1000),log(var.values.S),xlab="log of the number of leaves",
     ylab="log of the variance")
reg.S=lm(log(var.values.S[500:1000])~log(500:1000))
abline(reg.S,col="red",lwd=2) 
sackin.approx = ((10-3*pi)/3)*(1:1000)^3 
lines(log(1:1000),log(sackin.approx),col="cyan",lty=2,lwd=2)
```

### Computing the variance of $S$ from the Sackin indices {#realvarsackin}

To double-check the recurrence, we have computed the values of
$\sigma_U(S_n)$, for $n=3,\ldots,8$, from the Sackin indices of all trees in the corresponding $\mathcal{BT}_n$.

First of all, we have considered all the phylogenetic trees in $\mathcal{BT}_n$ for $n=3,\ldots,8$ obtained with the package *phylonetwork* for *Python* in the [$\color{blue}{\text{this section}}$](#bintrees).

Afterwards, we can compute the Sackin index with the package *CollessLike* and compute the variance of the indices of each $n$:
```{r,eval=FALSE}
var.n = function (vec) return(var(vec)*(length(vec)-1)/length(vec))
trees = list()
all.sackin.index = list()
real.var.sackin = c()
for(n in 3:8){
  trees[[n]] = read.tree(file = paste("bintrees-n",n,".txt",sep = ""))
  all.sackin.index[[n]] = sapply(trees[[n]],sackin.index)
  real.var.sackin[n] = var.n(all.sackin.index[[n]])
  print(paste("var(S_",n,") = ",real.var.sackin[n],sep = ""))
}
```
Obtaining the following results:

$n$             | 3 |   4  |    5   |    6   |   7    |   8 
----------------|:---:|:---:|:------:|:------:|:-------:|:-------:
$\sigma^2_U(S_n)$| 0 | 0.16 | 0.7755 | 2.2358 | 4.9991 | 9.5765

agreeing with the figures given by our recurrence.

***

## 3.7 On the covariance of $S$ and $\Phi$ under the uniform model {#cov}

### Computing the covariance of $S_n$ and $\Phi_n$  using our formula 

We can compute $Cov_U(S_n,\Phi_n)$ using the recurrence formula for
$E_U(S_n\Phi_n)$ and the exact formula of $E_U(S_n)$ and $E_U(\Phi)$, and obtaining:
$$Cov_U(S_n,\Phi_n)=E_U(S_n\Phi_n)-E_U(S_n)E_U(\Phi)$$

The following functions are needed to compute the covariance, in addition to the functions of the common block ([$\color{blue}{\text{see this section}}$](#cofun)) and `EUPhi` from [$\color{blue}{\text{Section 3.5}}$](#varphi) and `EUS` from [$\color{blue}{\text{Section 3.6}}$](#varsackin)
```{r,eval=FALSE}
term.cov = function(n){
  return(((13*n^2-9*n-2)*2^(n-5)*big.factorial(n))/(big.double.factorial(2*n-3))-
           (n*(n-1)/2)*(5*n-2)) 
} 

compute.EUcov = function(n.max=500){
  terms = lapply(2:n.max,term.cov)
  terms = c(0,terms)
  exp.values = list(0)
  for(n in 2:n.max){
    sums = 0
    if(n>2){ 
      for(k in 2:(n-1)){ 
        sums = sums + Cknk(k,n)*exp.values[[k]]
      }
      sums = 2*sums
    }
    sums = sums + terms[[n]]
    exp.values[[n]] = sums
    print(n)
  }
  exp.values = sapply(exp.values, as.numeric)
  write.table(exp.values,file=paste("EU(SxPhi)",n.max,".txt",sep = ""),
              row.names = F,col.names = F)
  return(exp.values)
}

compute.cov = function(exp.values,n.max = 500){
  cov.form = function(i)return(exp.values[i]-EUS(i)*EUPhi(i))
  cov.values = sapply(1:n.max, cov.form)
  write.table(cov.values,file = paste("covU(SPhi)",n.max,".txt",sep = ""),
              row.names = F,col.names = F)
  return(cov.values)
}
```

We have computed these covariances and correlations up to $n=1000$ with the following instructions:
```{r, eval=FALSE} 
exp.values.cov = compute.EUcov(1000)
cov.values = compute.cov(exp.values.cov,1000)
```
NOTE: these computations might take a long time to finish.

For $n=3,...,20$ the results have been:
```{r, echo=FALSE}
exp.values.cov = read.table("./EU(SxPhi)1000.txt")[,1]
cov.values = read.table("./covU(SPhi)1000).txt")[,1]
```
```{r}
exp.values.cov[3:20]
cov.values[3:20]
```

The rest of the values are available in the files "EU(SxPhi)1000.txt" and "covU(SPhi)1000.txt". 

We have estimated  the main order in the expansion of $Cov_U(S_n, \Phi_n)$ as a function of $n$, by performing 
the minimum squares linear regression of $\ln(Cov_U(S_n, \Phi_n))$ as a function of $\ln(n)$ for $n=900,\ldots, 1000$, 
```{r}
summary(lm(log(cov.values[900:1000])~log(900:1000)))
```
and the result has been 
$$
\ln(Cov_U(S_n, \Phi_n))\approx -3.1333995 + 4.0709153 \cdot \ln(n),
$$
with a determination coefficient $R^2 \approx 1$. We conclude then that, according to our approximations, 
$Cov_U(S_n, \Phi_n)$ is in $O(n^{4.0709153})$. We conjecture that, actually, $Cov_U(S_n, \Phi_n)$ is in $O(n^{4})$, the order of $E_U(S_n)E_U(\Phi_n)$.
Next figure displays $\ln(Cov_U(S_n, \Phi_n))$ as a function of $\ln(n)$, together with the corresponding regression line. 
```{r}
plot(log(1:1000),log(cov.values),xlab="log of the number of leaves",
     ylab="log of the variance")
reg.cov=lm(log(cov.values[500:1000])~log(500:1000))
abline(reg.cov,col="violet",lwd=2)  
```

### Computing the covariance of $S$ and $\Phi$ from the values of the indices 

To double-check the recurrence, we have computed the values of
$Cov_U(S_n\Phi_n)$, for $n=3,\ldots,8$, from the Sackin and cophenetic indices of all trees in the corresponding $\mathcal{BT}_n$. 

First of all, we have considered all the phylogenetic trees in $\mathcal{BT}_n$ for $n=3,\ldots,8$ obtained with the package *phylonetwork* for *Python* in [$\color{blue}{\text{this section}}$](#bintrees), then we have computed the Sackin index, `all.sackin.index`,and the cophenetic index, `all.cophen.index`, of all of them (correspondingly in [$\color{blue}{\text{Section 3.6}}$](#realvarphi) and [$\color{blue}{\text{Section 3.7}}$](#realvarsackin)).

Afterwards, we can compute the covariance of the indices for each $n$:
```{r,eval=FALSE}
covariancesU = function(n){
  len = length(all.sackin.index[[n]])
  value = cov(all.sackin.index[[n]],all.cophen.index[[n]]*(len-1)/len)
  return(value)
}
real.cov.values = sapply(3:7,covariancesU)
```
Obtaining the following results:

$n$               | 3 |   4  |    5   |    6   |    7    |   8 
------------------|:---:|:---:|:------:|:------:|:-------:|:-------:
$Cov_U(S_n,\Phi_n)$| 0 | 0.32 | 1.9184 | 6.5805 | 17.0441 | 37.0899

agreeing with the figures given by our recurrence.

Now, since we know how to compute recurrently $Cov_U(S_n, \Phi_n)$, $\sigma_U^2(S_n)$ and $\sigma_U^2(\Phi_n)$, we can compute Pearson's correlation $\rho$ of $S$ and $\Phi$ under the uniform model for any desired $n\geq 4$, by means of
$$
\rho_U( S_n, \Phi_n)=\frac{Cov_U(S_n, \Phi_n)}{\sigma_U(S_n)\cdot \sigma_U(\Phi_n)}.
$$
Therefore
```{r}
pearson.cor = function(n.max){
  return(cov.values[4:n.max]/sqrt(var.values.S[4:n.max]*var.values.Phi[4:n.max]))
}
```
For $n=4,...,20$ the results are:
```{r}
pearson.cor(20)
```

***

## 3.8.1 The discriminative power of $\Phi$ {#ties}

We have estimated the probability that a pair of trees $T_1,T_2\in \mathcal{BT}_n$ have $I(T_1)=I(T_2)$, for $I=C,S,\Phi$. Notice that if $T_1$ and $T_2$ do have the same topology, then all these indices must be equal on them: therefore, any difference in these probabilities must be due to pairs of trees with different topology but having the same index.  
 
To compute the balance indices we use the function `balance.indices` from the package *CollessLike* but modified to compute the clasical Colless index
```{r}
balance.indices2 = function(tree){
  colless.coefficient = (log(0 + exp(1))+log(2 + exp(1)))/2 
  values = balance.indices(tree)
  values[1] = values[1]/colless.coefficient
  return(values)
}
```

For every $n=3,\ldots,50$ we have chosen uniformly a set of $N$ random pairs of trees in $\mathcal{BT}_n$ (for $n=3,\ldots,7$, we took $N=|\mathcal{BT}_n|$ and, for $n\geq 8$, we took $N=3000$), and computed, for $I=C,S,\Phi$,
$$
\widehat{p}_n(I)=\frac{\mbox{number of pairs $(T_1,T_2)$ with $n$ leaves such that $I(T_1)=I(T_2)$}}{N}.
$$
The following functions compute this probabilities
```{r}
are.tie = function(xx,yy) return(xx==yy) 

exact.ties = function(){
  trees = list()
  all.indices = list()
  num.ties = c(0,0,0) 
  prob.ties = list()
  for(n in 3:7){
    trees[[n]] = read.tree(file = paste("bintrees-n",n,".txt",sep=""))
    total.trees = length(trees[[n]])
    total.pairs = total.trees*(total.trees-1)/2
    all.indices[[n]] = matrix(sapply(trees[[n]],balance.indices2),ncol=3,byrow=T) 
    num.ties[1]=sum(outer(all.indices[[n]][,1],all.indices[[n]][,1],are.tie))
    num.ties[2]=sum(outer(all.indices[[n]][,2],all.indices[[n]][,2],are.tie))
    num.ties[3]=sum(outer(all.indices[[n]][,3],all.indices[[n]][,3],are.tie))
    num.ties = (num.ties-total.trees)/2
    prob.ties[[n]] = num.ties/total.pairs
    print(paste("Ties for n =",n," : ",
                paste(c("p_C=","p_S=","p_Phi"),round(prob.ties[[n]],4),collapse=", "),sep=""))
  }
  return(prob.ties)
}

sim.ties.n = function(n,num.pairs.sim=3000){ 
  num.ties = c(0,0,0)
  for(i in 1:num.pairs.sim){
    t1 = rtree(n,rooted=TRUE)
    continue = TRUE
    while(continue){
      t2 = rtree(n,rooted=TRUE)
      continue = all.equal(t1,t2,use.length=FALSE,use.tip.label=FALSE)
    }
    t1.indices = balance.indices2(t1)
    t2.indices = balance.indices2(t2)
    num.ties = num.ties + (t1.indices==t2.indices)
  } 
  print(paste("n =",n))
  print(paste("Ties :",num.ties))
  prob.ties = num.ties/num.pairs.sim
  print(paste("Prob :",round(prob.ties,4)))
  return(prob.ties)
}
```

Now, with this instructions we compute the probabilities for each $n=3,\ldots,50$
```{r,eval=FALSE}
ties.1 = exact.ties()
ties.2 = lapply(8:50, sim.ties.n,num.pairs.sim=3000)
ties = matrix(c(unlist(ties.1),unlist(ties.2)),ncol=3,byrow=TRUE)
colnames(ties)=c("Colless","Sackin","Cophenetic")
rownames(ties)=3:50
```
For $n=4,...,20$ the results are:
```{r,eval=FALSE}
ties[1:18,]
```
```{r,echo=FALSE}
ties=read.table("./C3-table-ties.txt")
kable(ties[1:18,])
```


The whole table is available at "C3-table-ties.txt".

Next figure summarizes the results. It plots $\log(\hat{p}_n(I))$ for the three balance indices  as a function of $\log(n)$. We can see that that $\Phi$ has the lowest relative frequency of ties.
```{r}
plot(log(3:50),log(ties[,3]),type="l",
     xlab="log of the number of leaves",
     ylab="log of the probability of tie", col="blue")
lines(log(3:50),log(ties[,1]),col="red")
lines(log(3:50),log(ties[,2]),col="green")
legend("bottomleft", legend=c("Sackin","Colless","Cophenetic"),
       col=c("green","red", "blue"),lty=1, cex=0.8)
```

***

## 3.8.2 A test on TreeBASE {#tb}

In this subsection we perform a simple test to check which of the models Yule or uniform is the one that better fits the TreeBASE using the total cophenetic index. 

We have considerated all the trees from TreeBASE. The list is available in the _List of Trees_ folder of the GitHub repository as a text file or as an `R` object.
```{r,eval=FALSE}
# Option 1
tb.ape = read.tree(file = "./tb-newicks.txt")
# Option 2
load("./treeBASE-database.RData")
```

We have taken the numbers $n$ of leaves for which the TreeBASE contains at least 20 binary phylogenetic trees with $n$ leaves, and for each such $n$ we have computed the mean of the total cophenetic indices of the corresponding binary trees. 
```{r,eval=FALSE}
bin.tb.ape=tb.ape[sapply(tb.ape,is.rooted)] 
bin.tb.ape=bin.tb.ape[sapply(bin.tb.ape,is.binary)] 
bin.tb.n = sapply(bin.tb.ape,Ntip)
leaves=as.numeric(names(which(table(bin.tb.n)>20)))
bin.tb.mean = c()
indices.tb = list()
for(k in leaves){
  trees = bin.tb.ape[bin.tb.n==k]
  indices.tb[[k]] = sapply(trees, cophen.index)
  value = mean( indices.tb[[k]] )
  bin.tb.mean = rbind(bin.tb.mean,c(k,value))
}
```
The results of this computations are available in "C3-table-tb-means.txt".
```{r,echo=FALSE}
bin.tb.mean=read.table("./C3-table-tb-means.txt",header = TRUE)
```


The following code computes $E_Y(\Phi_n)$ and $E_U(\Phi_n)$ for $n=3,\dots,140$, using functions `EYPhi` and `EUPhi` from [$\color{blue}{\text{Section 3.3}}$](#eyphi) and [$\color{blue}{\text{Section 3.4}}$](#eyphi), respectively:
```{r}
range.plot = 3:140
eyphi.values = sapply(range.plot, EYPhi)
euphi.values = sapply(range.plot, EUPhi) 
```
Using the computations of the variance of $\Phi_n$ under the uniform model ([$\color{blue}{\text{from this section}}$](#varphi)) and the exact formula for $\sigma^2_Y(\Phi_n)$ (Formula 3.2) we can obtain the reference intervals for $\Phi_n$ that will be drawn in the figure.
```{r}  
harmonic2 = function(n){return(sum(1/((1:n)^2)))}
varYPhi = function(n){
  return((n^4-10*n^3+131*n^2-2*n)/12-4*n^2*harmonic2(n)-6*n*harmonic(n))
} 
varYPhi.values = sapply(range.plot,varYPhi)
intY = cbind(range.plot,log(eyphi.values-1*sqrt(varYPhi.values)),
               log(eyphi.values+1*sqrt(varYPhi.values)))
intU = cbind(range.plot,log(euphi.values-1*sqrt(var.values.Phi[range.plot])),
               log(euphi.values+1*sqrt(var.values.Phi[range.plot])))

draw.intervals = function(range.plot,int.yule,int.uniform,delta=0){
  epsilon = 0.3 
  for(i in range.plot){
    lines(c(i ,i ),int.uniform[i-2,2:3],col="cyan")
    lines(c(i-epsilon,i+epsilon),rep(int.uniform[i-2,2],2),col="cyan") 
    lines(c(i-epsilon,i+epsilon),rep(int.uniform[i-2,3],2),col="cyan") 
    lines(c(i ,i )-delta,int.yule[i-2,2:3],col="violet")
    lines(c(i-epsilon,i+epsilon)-delta,rep(int.yule[i-2,2],2),col="violet")
    lines(c(i-epsilon,i+epsilon)-delta,rep(int.yule[i-2,3],2),col="violet")
  }
}
```


Next figure shows the plot the log of these means as a function of  $n$. We have added the curves of the log of the expected values of $\Phi_n$ under the Yule distribution (lower red curve) and under the uniform distribution (upper blue curve), again as a function of  $n$, and the logarithms of the corresponding reference intervals for $\Phi_n$ (vertical segments).
```{r}   
plot(NULL,NULL,col="blue",xlab="number of leaves",
      ylab="log of means",xlim=c(3,130),ylim=c(1,11.5),
     type="l",lwd=2)
draw.intervals(range.plot,intY,intU,delta=0.3) 
lines(range.plot,log(eyphi.values),col="red",lwd=2)
lines(range.plot,log(euphi.values),col="blue",lwd=2)
lines(bin.tb.mean[,1],log(bin.tb.mean[,2]),type="l",lwd=2) 
legend("bottomright", legend=c(expression(E[U]*(Phi[n])),"Uniform intervals","Treebase",
        expression(E[Y]*(Phi[n])),"Yule intervals"),col=c( "blue","cyan","black","red",
        "violet"),lty=1,cex=0.8)   
```
This figure shows that the total cophenetic indices of the binary phylogenetic trees in TreeBASE seem to be better explained by the uniform model than by the Yule  model. 

